// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import "../interfaces/IUniswapV2Pair.sol";
import "../interfaces/IUniswapV2Router.sol";
import "../interfaces/IStakingDualRewards.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "../interfaces/IUniswapV2Factory.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "../utils/Cooldown.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";

contract QuickswapDualFarmUpgradeable is UUPSUpgradeable, Initializable, OwnableUpgradeable, ReentrancyGuard, Cooldown {
    using SafeMath for uint256;
    using SafeERC20Upgradeable for IERC20Upgradeable;

      /**
     * @dev Tokens Used:
     * {WETH} - WETH token address, used in routing.
     * {QUICK} - QUICK token address, used as a fallback if [WETH - tokenA/tokenB] pair doesn't exist.
     * {rewardTokenA, rewardTokenB} - Tokens generated by staking.
     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the {lpStakingPool}.
     * {tokenA, tokenB} - Tokens that the strategy maximizes.
     */
    address private constant WETH = address(0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619);//UNUSED
    address private constant QUICK = address(0x831753DD7087CaC61aB5644b308642cc1c33Dc13);//UNUSED
    address public rewardTokenA;
    address public rewardTokenB;
    address public lpPair;
    address public tokenA;
    address public tokenB;
    
    /**
     * @dev Third Party Contracts:
     * {quickswapRouter} - The contract that executes swaps.
     * {QuickswapV2Factory} - Pairs factory contract.
     * {lpStakingPool} - The contract that distibutes {rewardTokenA, rewardTokenB}.
     */
    IUniswapV2Router01 private constant quickswapRouter = IUniswapV2Router01(0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff);
    IUniswapV2Factory private constant QuickswapV2Factory = IUniswapV2Factory(0x5757371414417b8C6CAad45bAeF941aBc7d3Ab32);//UNUSED
    IStakingDualRewards private lpStakingPool;
    
     /**
     * @dev Routes:
     * {rewardTokenAToTokenARoute, rewardTokenAToTokenBRoute, rewardTokenBToTokenARoute, rewardTokenBToTokenBRoute} - The routes to trade tokens with.
     */
    address[] private rewardTokenAToTokenARoute;//UNUSED
    address[] private rewardTokenAToTokenBRoute;//UNUSED
    
    address[] private rewardTokenBToTokenARoute;//UNUSED
    address[] private rewardTokenBToTokenBRoute;//UNUSED
    
    /**
     * @dev Contract Variables:
     * The implementation of “Scalable Reward Distribution on the Ethereum Blockchain” paper by B. Batog, L. Boca and N. Johnson.
     * {totalDeposits} - The sum of all active stake deposits | (T).
     * {sumOfRewards} - The sum of (rewards)/(totalDeposits) | (S).
     * {stakes} - All stakes made by users | (stake).
     * {sumOfRewardsForUser} - A sumOfRewards for users at pool join time | (S0).
     */
    uint256 private totalDeposits;
    uint256 private sumOfRewards;
    mapping(address => uint256) private stakes;
    mapping(address => uint256) private sumOfRewardsForUser;

    // ============ Methods ============
    
    function initialize(address _lpStakingPool, address owner) public initializer {
        __Ownable_init();
        transferOwnership(owner);

        lpStakingPool = IStakingDualRewards(_lpStakingPool);
        lpPair = address(lpStakingPool.stakingToken());
        
        rewardTokenA = lpStakingPool.rewardsTokenA();
        rewardTokenB = lpStakingPool.rewardsTokenB();
        
        tokenA = IUniswapV2Pair(lpPair).token0();
        tokenB = IUniswapV2Pair(lpPair).token1();
        
        uint256 MAX_UINT = uint256(2**256 - 1);
        IERC20(lpPair).approve(_lpStakingPool, MAX_UINT);
        IERC20(lpPair).approve(address(quickswapRouter), MAX_UINT);
        IERC20(rewardTokenA).approve(address(quickswapRouter), MAX_UINT);
        IERC20(rewardTokenB).approve(address(quickswapRouter), MAX_UINT);
        IERC20(tokenA).approve(address(quickswapRouter), MAX_UINT);
        IERC20(tokenB).approve(address(quickswapRouter), MAX_UINT);
    }

    /**
     * @dev Function that makes the deposits.
     * If it's not the first deposit, withdraws {lpStakingPool} and deposits new tokens with the old ones.
     */
    function deposit(uint256 amountA, uint256 amountB, uint256 amountLP, address recipient) external onlyOwner nonReentrant returns(uint256 sentA, uint256 sentB, uint256 liquidity){
        uint256 withdrawAmount = 0;
        if (stakes[recipient] != 0) {
            withdrawAmount = _withdraw(recipient);
        }

        uint256 addedLiquidity;
        if(amountA > 0 && amountB > 0) {
            (sentA, sentB, addedLiquidity) = quickswapRouter.addLiquidity(tokenA, tokenB, amountA, amountB, 0, 0, address(this), block.timestamp.add(600));
        }

        liquidity = addedLiquidity.add(amountLP);
        require(liquidity > 0, 'The amount provided is 0');
        _deposit(recipient, liquidity.add(withdrawAmount));

        IERC20Upgradeable(tokenA).safeTransfer(recipient, amountA.sub(sentA));
        IERC20Upgradeable(tokenB).safeTransfer(recipient, amountB.sub(sentB));
    }

     /**
     * @dev Withdraws funds and sends them to the {recipient}.
     */
    function withdraw(address origin, uint256 amount, bool withdrawLP, address recipient) external onlyOwner nonReentrant returns(uint256 amountA, uint256 amountB){
        require(stakes[origin] > 0, "The amount staked should be more than 0");
        uint256 withdrawAmount = _withdraw(origin);

        uint256 depositAmount = withdrawAmount.sub(amount);
        if(depositAmount > 0) {
            _deposit(origin, depositAmount);
        }

        if(withdrawLP){
            IERC20Upgradeable(lpPair).safeTransfer(recipient, amount);
            return (0, 0);
        }
        (amountA, amountB) = quickswapRouter.removeLiquidity(tokenA, tokenB, amount, 0, 0, recipient, block.timestamp.add(600));
    }

    /**
     * @dev Withdraws funds to this contract.
     * It withdraws {lpPair} from the {lpStakingPool} to this contract.
     */
    function _withdraw(address _address) internal returns(uint256){
        uint256 withdrawAmount = userBalance(_address);
        totalDeposits = totalDeposits.sub(stakes[_address]);
        stakes[_address] = 0;
        
        lpStakingPool.withdraw(withdrawAmount);
        return withdrawAmount;
    }

    /**
     * @dev Deposits funds to lpStakingPool.
     */
    function _deposit(address _address, uint256 amount) internal {
        stakes[_address] = amount;
        sumOfRewardsForUser[_address] = sumOfRewards;
        totalDeposits = totalDeposits.add(amount);

        lpStakingPool.stake(amount);
    }

    /**
     * @dev Core function of the strat, in charge of updating, collecting and re-investing rewards.
     * 1. It claims rewards from the {lpStakingPool}.
     * 2. It swaps the {rewardTokenA} & {rewardTokenB} tokens for {tokenA} & {tokenB}.
     * 3. It deposits the new LP tokens back to the {lpStakingPool}.
     */
    function distribute(address[] calldata _rewardTokenAToTokenARoute, address[] calldata _rewardTokenAToTokenBRoute, address[] calldata _rewardTokenBToTokenARoute, address[] calldata _rewardTokenBToTokenBRoute) external onlyOwner nonReentrant{
        require(totalDeposits > 0, 'There should be some tokens in the pool');
                
        lpStakingPool.getReward();
        uint256 rewardTokenAHalf = IERC20(rewardTokenA).balanceOf(address(this)).div(2);
        uint256 rewardTokenBHalf = IERC20(rewardTokenB).balanceOf(address(this)).div(2);
                
        if (tokenA != rewardTokenA) {
            quickswapRouter.swapExactTokensForTokens(rewardTokenAHalf, 0, _rewardTokenAToTokenARoute, address(this), block.timestamp.add(600));
        }
        
        if (tokenB != rewardTokenA) {
            quickswapRouter.swapExactTokensForTokens(rewardTokenAHalf, 0, _rewardTokenAToTokenBRoute, address(this), block.timestamp.add(600));
        }
        
        if (tokenA != rewardTokenB) {
            quickswapRouter.swapExactTokensForTokens(rewardTokenBHalf, 0, _rewardTokenBToTokenARoute, address(this), block.timestamp.add(600));
        }
        
        if (tokenB != rewardTokenB) {
            quickswapRouter.swapExactTokensForTokens(rewardTokenBHalf, 0, _rewardTokenBToTokenBRoute, address(this), block.timestamp.add(600));
        }
        
        uint256 tokenABalance = IERC20(tokenA).balanceOf(address(this));
        uint256 tokenBBalance = IERC20(tokenB).balanceOf(address(this));
                
        quickswapRouter.addLiquidity(tokenA, tokenB, tokenABalance, tokenBBalance, 1, 1, address(this), block.timestamp.add(600));
                
        uint256 reward = IERC20(lpPair).balanceOf(address(this));
        if (reward > 0) {
            sumOfRewards = sumOfRewards.add(uint256(1 ether).mul(reward).div(totalDeposits));
            lpStakingPool.stake(reward);
        }
    }

    /**
     * @dev Returns total funds staked by the {_address}.
     */
    function userBalance(address _address) public view returns (uint256) {
        uint256 reward = stakes[_address].mul(sumOfRewards.sub(sumOfRewardsForUser[_address])).div(uint256(1 ether));
        return stakes[_address].add(reward);
    }

    /**
     * @dev Returns total amount locked in the pool.
     */
    function getTotalDeposits() external view returns (uint256) {
        return totalDeposits.add(totalDeposits.mul(sumOfRewards).div(uint256(1 ether)));
    }

    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {

    }
}