// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import "../interfaces/IUniswapV2Pair.sol";
import "../interfaces/IUniswapV2Router.sol";
import "../interfaces/IMiniChefV2.sol";
import "../interfaces/IRewarder.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "../interfaces/IUniswapV2Factory.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "../utils/Cooldown.sol";

contract SushiswapFarmUpgradeable is UUPSUpgradeable, Initializable, OwnableUpgradeable, ReentrancyGuard, Cooldown {
    using SafeMath for uint256;

    /**
     * @dev Tokens Used:
     * {WMATIC} - WMATIC token address
     * {rewardToken} - Token generated by staking our funds (SUSHI).
     * {rewarderToken} - Token generated by ComplexRewarderTime contract (Second Reward token).
     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the {lpStakingPool}.
     * {lpToken0, lpToken1} - Tokens that the strategy maximizes.
     * {pid} - Pool ID
     */
    address private constant WMATIC = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);
    address public rewardToken;
    address public rewarderToken;
    address public lpPair;
    address public tokenA;
    address public tokenB;
    uint256 public pid;

    /**
     * @dev Third Party Contracts:
     * {sushiswapRouter} -  sushiswap router
     * {MiniChef} -The contract that produces {rewardToken}
     * {ComplexRewarderTime} -The contract that produces {rewarderToken}
     */
    IUniswapV2Router01 private constant sushiswapRouter = IUniswapV2Router01(0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506);
    IMiniChefV2 private constant MiniChef = IMiniChefV2(0x0769fd68dFb93167989C6f7254cd0D766Fb2841F);
    IRewarder private ComplexRewarderTime;

    /**
     * @dev Routes:
     * {rewardTokenToTokenARoute, rewardTokenToTokenBRoute} - The routes to trade {rewardToken} with
     * {rewarderTokenToTokenARoute, rewarderTokenToTokenBRoute} - The routes to trade {rewarderToken} with
     * {rewarderTokenToRewardToken} - The route to convert {rewarderToken} to {rewardToken}
     */
    address[] private rewardTokenToTokenARoute;
    address[] private rewardTokenToTokenBRoute;

    address[] private rewarderTokenToTokenARoute;
    address[] private rewarderTokenToTokenBRoute;

    address[] private rewarderTokenToRewardToken;
    
    /**
     * @dev Contract Variables:
     * The implementation of “Scalable Reward Distribution on the Ethereum Blockchain” paper by B. Batog, L. Boca and N. Johnson
     * {totalDeposits} - The sum of all active stake deposits | (T)
     * {sumOfRewards} - The sum of (rewards)/(totalDeposits) | (S)
     * {stakes} - All stakes made by users | (stake)
     * {sumOfRewardsForUser} - A sumOfRewards for users at pool join time | (S0)
     */
    uint256 private totalDeposits;
    uint256 private sumOfRewards;
    mapping(address => uint256) private stakes;
    mapping(address => uint256) private sumOfRewardsForUser;

    // ============ Methods ============

    function initialize(address _lpPair, address owner) public initializer {
        __Ownable_init();
        transferOwnership(owner);

        pid = getPid(_lpPair);

        rewardToken = MiniChef.SUSHI();
        ComplexRewarderTime = IRewarder(MiniChef.rewarder(pid));
        if (address(ComplexRewarderTime) != address(0)) {
            (IERC20[] memory rewarderTokenArray, ) = ComplexRewarderTime
                .pendingTokens(pid, address(0), 0);
            rewarderToken = address(rewarderTokenArray[0]);
        }

        lpPair = MiniChef.lpToken(pid);

        tokenA = IUniswapV2Pair(lpPair).token0();
        tokenB = IUniswapV2Pair(lpPair).token1();

        if (rewarderToken == WMATIC) {
            if (tokenA != WMATIC) {
                rewarderTokenToTokenARoute = [rewarderToken, tokenA];
            }
            if (tokenB != WMATIC) {
                rewarderTokenToTokenBRoute = [rewarderToken, tokenB];
            }
            if (rewardToken != WMATIC) {
                rewarderTokenToRewardToken = [rewarderToken, rewardToken];
            }
        } else {
            if (tokenA != WMATIC) {
                rewarderTokenToTokenARoute = [rewarderToken, WMATIC, tokenA];
            } else {
                rewarderTokenToTokenARoute = [rewarderToken, tokenA];
            }

            if (tokenB != WMATIC) {
                rewarderTokenToTokenBRoute = [rewarderToken, WMATIC, tokenB];
            } else {
                rewarderTokenToTokenBRoute = [rewarderToken, tokenB];
            }

            if (rewardToken != WMATIC) {
                rewarderTokenToRewardToken = [rewarderToken, WMATIC, rewardToken];
            } else {
                rewarderTokenToRewardToken = [rewarderToken, rewardToken];
            }
        }

        if (tokenA == WMATIC) {
            rewardTokenToTokenARoute = [rewardToken, WMATIC];
        } else if (tokenA != rewardToken) {
            rewardTokenToTokenARoute = [rewardToken, WMATIC, tokenA];
        }

        if (tokenB == WMATIC) {
            rewardTokenToTokenBRoute = [rewardToken, WMATIC];
        } else if (tokenB != rewardToken) {
            rewardTokenToTokenBRoute = [rewardToken, WMATIC, tokenB];
        }

        uint256 MAX_UINT = uint256(2**256 - 1);
        IERC20(lpPair).approve(address(MiniChef), MAX_UINT);
        IERC20(lpPair).approve(address(sushiswapRouter), MAX_UINT);
        IERC20(rewardToken).approve(address(sushiswapRouter), MAX_UINT);
        IERC20(rewarderToken).approve(address(sushiswapRouter), MAX_UINT);
        IERC20(tokenA).approve(address(sushiswapRouter), MAX_UINT);
        IERC20(tokenB).approve(address(sushiswapRouter), MAX_UINT);
    }

    /**
     * @dev Function that makes the deposits
     * If it's not the first deposit, withdraws {lpStakingPool} and deposits new tokens with the old ones.
     */
    function deposit(uint256 amountA, uint256 amountB, uint256 amountLP, address origin) external onlyOwner startCooldown(origin) nonReentrant returns(uint256){
        uint256 withdrawAmount = 0;
        if (stakes[origin] != 0) {
            withdrawAmount = withdrawToContract(origin);
        }

        uint256 sentA;
        uint256 sentB;
        uint256 addedLiquidity;
        
        if(amountA > 0 && amountB > 0){
            (sentA, sentB, addedLiquidity) = sushiswapRouter.addLiquidity(tokenA, tokenB, amountA, amountB, 0, 0, address(this), block.timestamp.add(600));
        }

        uint256 depositAmount = addedLiquidity.add(withdrawAmount).add(amountLP);
        require(depositAmount > 0, 'The amount provided is 0');

        stakes[origin] = depositAmount;
        sumOfRewardsForUser[origin] = sumOfRewards;
        totalDeposits = totalDeposits.add(depositAmount);

        MiniChef.deposit(pid, depositAmount, address(this));

        IERC20(tokenA).transfer(origin, amountA.sub(sentA));
        IERC20(tokenB).transfer(origin, amountB.sub(sentB)); 

        return depositAmount;
    }

    /**
     * @dev Withdraws funds and sends them to the {{msg.sender}}.
     */
    function withdraw(address origin, bool withdrawLP) external onlyOwner checkCooldown(origin) nonReentrant returns(uint256){
        require(stakes[origin] > 0, "The amount staked should be more than 0");
        uint256 withdrawAmount = withdrawToContract(origin);

        if(withdrawLP){
            IERC20(lpPair).transfer(origin, withdrawAmount);
            return withdrawAmount;
        }
        sushiswapRouter.removeLiquidity(tokenA, tokenB, withdrawAmount, 0, 0, origin, block.timestamp.add(600));
        return withdrawAmount;
    }

    /**
     * @dev Withdraws funds to this contract.
     * It withdraws {lpPair} from the {lpStakingPool} to this contract.
     */
    function withdrawToContract(address origin) internal returns(uint256){
        uint256 withdrawAmount = userBalance(origin);
        totalDeposits = totalDeposits.sub(stakes[origin]);
        MiniChef.withdraw(pid, withdrawAmount, address(this));
        stakes[origin] = 0;
        return withdrawAmount;
    }

    
    /**
     * @dev Core function of the strat, in charge of updating, collecting and re-investing rewards.
     * 1. It claims rewards from the {lpStakingPool}.
     * 2. It swaps the {rewardToken} token for {lpToken0} & {lpToken1}
     * 3. It deposits the new LP tokens back in the {lpStakingPool}.
     */
    function distribute() external onlyOwner nonReentrant{
        require(totalDeposits > 0, "There should be some tokens in the pool");

        MiniChef.harvest(pid, address(this));
        uint256 rewardTokenHalf = IERC20(rewardToken).balanceOf(address(this)).div(2);

        if (address(ComplexRewarderTime) != address(0)) {
            uint256 rewarderTokenHalf = IERC20(rewarderToken).balanceOf(address(this)).div(2);
            if (tokenA != rewarderToken) {
                sushiswapRouter.swapExactTokensForTokens(rewarderTokenHalf, 0, rewarderTokenToTokenARoute, address(this), block.timestamp.add(600));
            }

            if (tokenB != rewarderToken) {
                sushiswapRouter.swapExactTokensForTokens(rewarderTokenHalf, 0, rewarderTokenToTokenBRoute, address(this), block.timestamp.add(600));
            }
        }

        if (tokenA != rewardToken) {
            sushiswapRouter.swapExactTokensForTokens(rewardTokenHalf, 0, rewardTokenToTokenARoute, address(this), block.timestamp.add(600));
        }

        if (tokenB != rewardToken) {
            sushiswapRouter.swapExactTokensForTokens(rewardTokenHalf, 0, rewardTokenToTokenBRoute, address(this), block.timestamp.add(600));
        }

        uint256 tokenABalance = IERC20(tokenA).balanceOf(address(this));
        uint256 tokenBBalance = IERC20(tokenB).balanceOf(address(this));

        sushiswapRouter.addLiquidity(tokenA, tokenB, tokenABalance, tokenBBalance, 1, 1, address(this), block.timestamp.add(600));

        uint256 reward = IERC20(lpPair).balanceOf(address(this));
        if (reward > 0) {
            sumOfRewards = sumOfRewards.add(uint256(1 ether).mul(reward).div(totalDeposits));
            MiniChef.deposit(pid, reward, address(this));
        }
    }

    /**
     * @dev Returns total funds in the {_lpStakingPool} for an {_address}
     */
    function userBalance(address _address) public view returns (uint256) {
        uint256 reward = stakes[_address].mul(sumOfRewards.sub(sumOfRewardsForUser[_address])).div(uint256(1 ether));
        return stakes[_address].add(reward);
    }

    /**
     * @dev Returns total amount locked in the pool.
     */
    function getTotalDeposits() external view returns (uint256) {
        return totalDeposits.add(totalDeposits.mul(sumOfRewards).div(uint256(1 ether)));
    }

    /**
     * @dev Get pid by iterating over all pools and comparing pids.
     */
    function getPid(address _lpPair) internal view returns (uint256 _pid) {
        bool poolExists = false;
        for (uint256 i = 0; i < MiniChef.poolLength(); i++) {
            if (MiniChef.lpToken(i) == _lpPair) {
                _pid = i;
                poolExists = true;
                break;
            }
        }
        require(poolExists, "The pool with the given pair token doesn't exist");
        return _pid;
    }

    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {

    }
}