// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;

import "../interfaces/IUniswapV2Pair.sol";
import "../interfaces/IUniswapV2Router.sol";
import "../interfaces/IRewarder.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "../interfaces/IUniswapV2Factory.sol";
import "../interfaces/ICurvePool.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "../utils/Cooldown.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";

contract CurveFarmUpgradeable is UUPSUpgradeable, Initializable, OwnableUpgradeable, ReentrancyGuard, Cooldown {
    using SafeMath for uint256;
    using SafeERC20Upgradeable for IERC20Upgradeable;

    /**
     * @dev Tokens Used:
     * {WMATIC} - WMATIC token address, used in routing.
     * {rewardToken} - Token generated by staking (SUSHI).
     * {rewarderToken} - Token generated by ComplexRewarderTime contract.
     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the {lpStakingPool}.
     * {tokenA, tokenB} - Tokens that the strategy maximizes.
     * {pid} - Pool ID.
     */
    address private constant WMATIC = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);//UNUSED
    address public rewardToken;
    address public rewarderToken;
    address public lpPair;
    address public tokenA;
    address public tokenB;
    uint256 public pid;

    /**
     * @dev Third Party Contracts:
     * {sushiswapRouter} - The contract that executes swaps.
     * {MiniChef} -The contract that distibutes {rewardToken}.
     * {ComplexRewarderTime} -The contract that distibutes {rewarderToken}.
     */
    IRewarder private ComplexRewarderTime;

    /**
     * @dev Routes:
     * {rewardTokenToTokenARoute, rewardTokenToTokenBRoute, rewarderTokenToTokenARoute, rewarderTokenToTokenBRoute, rewarderTokenToRewardToken} - The routes to trade tokens with.
     */
    address[] private rewardTokenToTokenARoute;//UNUSED
    address[] private rewardTokenToTokenBRoute;//UNUSED

    address[] private rewarderTokenToTokenARoute;//UNUSED
    address[] private rewarderTokenToTokenBRoute;//UNUSED

    address[] private rewarderTokenToRewardToken;//UNUSED
    
    /**
     * @dev Contract Variables:
     * The implementation of “Scalable Reward Distribution on the Ethereum Blockchain” paper by B. Batog, L. Boca and N. Johnson.
     * {totalDeposits} - The sum of all active stake deposits | (T).
     * {sumOfRewards} - The sum of (rewards)/(totalDeposits) | (S).
     * {stakes} - All stakes made by users | (stake).
     * {sumOfRewardsForUser} - A sumOfRewards for users at pool join time | (S0).
     */
    uint256 private totalDeposits;
    uint256 private sumOfRewards;
    mapping(address => uint256) private stakes;
    mapping(address => uint256) private sumOfRewardsForUser;

    // ============ Methods ============

    function initialize(address _lpPair, address owner) public initializer {
        __Ownable_init();
        transferOwnership(owner);

        pid = getPid(_lpPair);
        tokenA = IUniswapV2Pair(lpPair).token0();
        tokenB = IUniswapV2Pair(lpPair).token1();

        uint256 MAX_UINT = uint256(2**256 - 1);
    }

    /**
     * @dev Function that makes the deposits.
     * If it's not the first deposit, withdraws {lpStakingPool} and deposits new tokens with the old ones.
     */
    function deposit(uint256 amountA, uint256 amountB, uint256 amountLP, address recipient) external onlyOwner nonReentrant returns(uint256 sentA, uint256 sentB, uint256 liquidity){
        uint256 withdrawAmount = 0;
        if (stakes[recipient] != 0) {
            withdrawAmount = _withdraw(recipient);
        }

        uint256 addedLiquidity;
        if(amountA > 0 && amountB > 0){
            ICurvePool(0x445fe580ef8d70ff569ab36e80c647af338db351).add_liquidity(amountA, amountB);
        }
    }

    /**
     * @dev Withdraws funds and sends them to the {recipient}.
     */
    function withdraw(address origin, uint256 amount, bool withdrawLP, address recipient) external onlyOwner nonReentrant returns(uint256 amountA, uint256 amountB){
        require(stakes[origin] > 0, "The amount staked should be more than 0");
        uint256 withdrawAmount = _withdraw(origin);

        uint256 depositAmount = withdrawAmount.sub(amount);
        if(depositAmount > 0) {
            _deposit(origin, depositAmount);
        }

        if(withdrawLP){
            IERC20Upgradeable(lpPair).safeTransfer(recipient, amount);
            return (0, 0);
        }

        ICurvePool(0x445fe580ef8d70ff569ab36e80c647af338db351).remove_liquidity(amountA, amountB);
    }

    /**
     * @dev Returns total funds staked by the {_address}.
     */
    function userBalance(address _address) public view returns (uint256) {
        uint256 reward = stakes[_address].mul(sumOfRewards.sub(sumOfRewardsForUser[_address])).div(uint256(1 ether));
        return stakes[_address].add(reward);
    }

    /**
     * @dev Returns total amount locked in the pool.
     */
    function getTotalDeposits() external view returns (uint256) {
        return totalDeposits.add(totalDeposits.mul(sumOfRewards).div(uint256(1 ether)));
    }

    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {

    }
}