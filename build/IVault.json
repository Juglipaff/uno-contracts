{
  "contractName": "IVault",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        }
      ],
      "name": "getPoolTokens",
      "outputs": [
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "balances",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256",
          "name": "lastChangeBlock",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "contract IAsset[]",
              "name": "assets",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "maxAmountsIn",
              "type": "uint256[]"
            },
            {
              "internalType": "bytes",
              "name": "userData",
              "type": "bytes"
            },
            {
              "internalType": "bool",
              "name": "fromInternalBalance",
              "type": "bool"
            }
          ],
          "internalType": "struct IVault.JoinPoolRequest",
          "name": "request",
          "type": "tuple"
        }
      ],
      "name": "joinPool",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "address payable",
          "name": "recipient",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "contract IAsset[]",
              "name": "assets",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "minAmountsOut",
              "type": "uint256[]"
            },
            {
              "internalType": "bytes",
              "name": "userData",
              "type": "bytes"
            },
            {
              "internalType": "bool",
              "name": "toInternalBalance",
              "type": "bool"
            }
          ],
          "internalType": "struct IVault.ExitPoolRequest",
          "name": "request",
          "type": "tuple"
        }
      ],
      "name": "exitPool",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum IVault.SwapKind",
          "name": "kind",
          "type": "uint8"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "poolId",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "assetInIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "assetOutIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "userData",
              "type": "bytes"
            }
          ],
          "internalType": "struct IVault.BatchSwapStep[]",
          "name": "swaps",
          "type": "tuple[]"
        },
        {
          "internalType": "contract IAsset[]",
          "name": "assets",
          "type": "address[]"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "fromInternalBalance",
              "type": "bool"
            },
            {
              "internalType": "address payable",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "toInternalBalance",
              "type": "bool"
            }
          ],
          "internalType": "struct IVault.FundManagement",
          "name": "funds",
          "type": "tuple"
        },
        {
          "internalType": "int256[]",
          "name": "limits",
          "type": "int256[]"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        }
      ],
      "name": "batchSwap",
      "outputs": [
        {
          "internalType": "int256[]",
          "name": "",
          "type": "int256[]"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    }
  ],
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"enum IVault.SwapKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"assetInIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetOutIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct IVault.BatchSwapStep[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"contract IAsset[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"fromInternalBalance\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"toInternalBalance\",\"type\":\"bool\"}],\"internalType\":\"struct IVault.FundManagement\",\"name\":\"funds\",\"type\":\"tuple\"},{\"internalType\":\"int256[]\",\"name\":\"limits\",\"type\":\"int256[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"batchSwap\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"\",\"type\":\"int256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IAsset[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"toInternalBalance\",\"type\":\"bool\"}],\"internalType\":\"struct IVault.ExitPoolRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"exitPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"}],\"name\":\"getPoolTokens\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"lastChangeBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IAsset[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"fromInternalBalance\",\"type\":\"bool\"}],\"internalType\":\"struct IVault.JoinPoolRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"joinPool\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"batchSwap(uint8,(bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,address,bool),int256[],uint256)\":{\"details\":\"Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either the amount of tokens sent to or received from the Pool, depending on the `kind` value. Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at the same index in the `assets` array. Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or `amountOut` depending on the swap kind. Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`. The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses, or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault. Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies the minimum or maximum amount of each token the vault is allowed to transfer. `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the equivalent `swap` call. Emits `Swap` events.\"},\"exitPool(bytes32,address,address,(address[],uint256[],bytes,bool))\":{\"details\":\"Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see `getPoolTokenInfo`). If the caller is not `sender`, it must be an authorized relayer for them. The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault: it just enforces these minimums. If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit. `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final `assets` array might not be sorted. Pools with no registered tokens cannot be exited. If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise, an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to do so will trigger a revert. `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the `tokens` array. This array must match the Pool's registered tokens. This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement their own custom logic. This typically requires additional information from the user (such as the expected number of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and passed directly to the Pool's contract. Emits a `PoolBalanceChanged` event.\"},\"joinPool(bytes32,address,address,(address[],uint256[],bytes,bool))\":{\"details\":\"Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized Pool shares. If the caller is not `sender`, it must be an authorized relayer for them. The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces these maximums. If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent back to the caller (not the sender, which is important for relayers). `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final `assets` array might not be sorted. Pools with no registered tokens cannot be joined. If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be withdrawn from Internal Balance: attempting to do so will trigger a revert. This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement their own custom logic. This typically requires additional information from the user (such as the expected number of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed directly to the Pool's contract, as is `recipient`. Emits a `PoolBalanceChanged` event.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"project:/contracts/interfaces/IVault.sol\":\"IVault\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://5a7d5b1ef5d8d5889ad2ed89d8619c09383b80b72ab226e0fe7bde1636481e34\",\"dweb:/ipfs/QmebXWgtEfumQGBdVeM6c71McLixYXQP5Bk6kKXuoY4Bmr\"]},\"project:/contracts/interfaces/IAsset.sol\":{\"keccak256\":\"0xd0af11a4031b09c503f43facb5843e6dc09b94247f416153cb116546bb439389\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://ded2df074ca1097b86a7acd7ef97ce10ef7f9cdc44e4c5629bde5c4e69116f76\",\"dweb:/ipfs/QmZ5TQkm2UzyqZEMSdCaxd7Lm12KUxzX6hmAcridrcWuCa\"]},\"project:/contracts/interfaces/IVault.sol\":{\"keccak256\":\"0xecc5f517e934fe9d3128d790ade9f2e662ac334e3c3d3408a295788185d359fa\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://478af291da63f84543930ed2eff08ff34148501e58c60c2d60f4a7d6167340a4\",\"dweb:/ipfs/QmY4eqDPHYdYfkRc7xNpYqeYjktS7SWf7xVHRbSbiG7jsV\"]}},\"version\":1}",
  "bytecode": "0x",
  "deployedBytecode": "0x",
  "immutableReferences": {},
  "generatedSources": [],
  "deployedGeneratedSources": [],
  "sourceMap": "",
  "deployedSourceMap": "",
  "source": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./IAsset.sol\";\r\n\r\npragma solidity 0.8.10;\r\n\r\ninterface IVault{\r\n    function getPoolTokens(bytes32 poolId)\r\n        external\r\n        view\r\n        returns (\r\n            IERC20[] memory tokens,\r\n            uint256[] memory balances,\r\n            uint256 lastChangeBlock\r\n        );\r\n\r\n    /**\r\n     * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\r\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\r\n     * Pool shares.\r\n     *\r\n     * If the caller is not `sender`, it must be an authorized relayer for them.\r\n     *\r\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\r\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\r\n     * these maximums.\r\n     *\r\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\r\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\r\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\r\n     * back to the caller (not the sender, which is important for relayers).\r\n     *\r\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\r\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\r\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\r\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\r\n     *\r\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\r\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\r\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\r\n     *\r\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\r\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\r\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\r\n     * directly to the Pool's contract, as is `recipient`.\r\n     *\r\n     * Emits a `PoolBalanceChanged` event.\r\n     */\r\n    function joinPool(\r\n        bytes32 poolId,\r\n        address sender,\r\n        address recipient,\r\n        JoinPoolRequest memory request\r\n    ) external payable;\r\n\r\n    struct JoinPoolRequest {\r\n        IAsset[] assets;\r\n        uint256[] maxAmountsIn;\r\n        bytes userData;\r\n        bool fromInternalBalance;\r\n    }\r\n\r\n    /**\r\n     * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\r\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\r\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\r\n     * `getPoolTokenInfo`).\r\n     *\r\n     * If the caller is not `sender`, it must be an authorized relayer for them.\r\n     *\r\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\r\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\r\n     * it just enforces these minimums.\r\n     *\r\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\r\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\r\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\r\n     *\r\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\r\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\r\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\r\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\r\n     *\r\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\r\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\r\n     * do so will trigger a revert.\r\n     *\r\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\r\n     * `tokens` array. This array must match the Pool's registered tokens.\r\n     *\r\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\r\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\r\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\r\n     * passed directly to the Pool's contract.\r\n     *\r\n     * Emits a `PoolBalanceChanged` event.\r\n     */\r\n    function exitPool(\r\n        bytes32 poolId,\r\n        address sender,\r\n        address payable recipient,\r\n        ExitPoolRequest memory request\r\n    ) external;\r\n\r\n    struct ExitPoolRequest {\r\n        IAsset[] assets;\r\n        uint256[] minAmountsOut;\r\n        bytes userData;\r\n        bool toInternalBalance;\r\n    }\r\n\r\n\r\n    // Swaps\r\n    //\r\n    // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\r\n    // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\r\n    // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\r\n    //\r\n    // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\r\n    // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\r\n    // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\r\n    // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\r\n    // individual swaps.\r\n    //\r\n    // There are two swap kinds:\r\n    //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\r\n    // `onSwap` hook) the amount of tokens out (to send to the recipient).\r\n    //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\r\n    // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\r\n    //\r\n    // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\r\n    // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\r\n    // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\r\n    // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\r\n    // the final intended token.\r\n    //\r\n    // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\r\n    // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\r\n    // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\r\n    // much less gas than they would otherwise.\r\n    //\r\n    // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\r\n    // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\r\n    // updating the Pool's internal accounting).\r\n    //\r\n    // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\r\n    // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\r\n    // minimum amount of tokens to receive (by passing a negative value) is specified.\r\n    //\r\n    // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\r\n    // this point in time (e.g. if the transaction failed to be included in a block promptly).\r\n    //\r\n    // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\r\n    // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\r\n    // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\r\n    // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\r\n    //\r\n    // Finally, Internal Balance can be used when either sending or receiving tokens.\r\n\r\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\r\n\r\n    /**\r\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\r\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\r\n     *\r\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\r\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\r\n     * the same index in the `assets` array.\r\n     *\r\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\r\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\r\n     * `amountOut` depending on the swap kind.\r\n     *\r\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\r\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\r\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\r\n     *\r\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\r\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\r\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\r\n     * or unwrapped from WETH by the Vault.\r\n     *\r\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\r\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\r\n     *\r\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\r\n     * equivalent `swap` call.\r\n     *\r\n     * Emits `Swap` events.\r\n     */\r\n    function batchSwap(\r\n        SwapKind kind,\r\n        BatchSwapStep[] memory swaps,\r\n        IAsset[] memory assets,\r\n        FundManagement memory funds,\r\n        int256[] memory limits,\r\n        uint256 deadline\r\n    ) external payable returns (int256[] memory);\r\n\r\n    /**\r\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\r\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\r\n     *\r\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\r\n     * from the previous swap, depending on the swap kind.\r\n     *\r\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\r\n     * used to extend swap behavior.\r\n     */\r\n    struct BatchSwapStep {\r\n        bytes32 poolId;\r\n        uint256 assetInIndex;\r\n        uint256 assetOutIndex;\r\n        uint256 amount;\r\n        bytes userData;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\r\n     * `recipient` account.\r\n     *\r\n     * If the caller is not `sender`, it must be an authorized relayer for them.\r\n     *\r\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\r\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\r\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\r\n     * `joinPool`.\r\n     *\r\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\r\n     * transferred. This matches the behavior of `exitPool`.\r\n     *\r\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\r\n     * revert.\r\n     */\r\n    struct FundManagement {\r\n        address sender;\r\n        bool fromInternalBalance;\r\n        address payable recipient;\r\n        bool toInternalBalance;\r\n    }\r\n}",
  "sourcePath": "C:\\Users\\nick_\\OneDrive\\Документы\\UNO\\Solidity\\autostrats_balancer\\uno-contracts\\contracts\\interfaces\\IVault.sol",
  "ast": {
    "absolutePath": "project:/contracts/interfaces/IVault.sol",
    "exportedSymbols": {
      "IAsset": [
        14358
      "IVault": [
        15897
      ]
    },
    "id": 15898,
        15897
      ]
    },
    "id": 15898,
      },
      {
        "absolutePath": "@openzeppelin/contracts/token/ERC20/IERC20.sol",
        "file": "@openzeppelin/contracts/token/ERC20/IERC20.sol",
        "id": 15780,
        "src": "739:56:63",
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "absolutePath": "project:/contracts/interfaces/IAsset.sol",
        "file": "./IAsset.sol",
        "id": 15782,
        "nameLocation": "-1:-1:-1",
        "nodeType": "ImportDirective",
        "id": 15781,
        "nameLocation": "-1:-1:-1",
        "nodeType": "ImportDirective",
        "scope": 15898,
          ".10"
        ],
        "nodeType": "PragmaDirective",
        "src": "823:23:63"
      },
      {
        "abstract": false,
        "baseContracts": [],
        "id": 15782,
        "nameLocation": "-1:-1:-1",
        "nodeType": "ImportDirective",
        "scope": 15898,
        "sourceUnit": 14359,
            "functionSelector": "f94d4668",
            "id": 15797,
            "implemented": false,
            "kind": "function",
            "modifiers": [],
        "id": 15783,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 15785,
                  "mutability": "mutable",
                  "name": "poolId",
                  "nameLocation": "904:6:63",
                  "nodeType": "VariableDeclaration",
                  "scope": 15797,
                  "src": "896:14:63",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes32",
        "id": 15897,
        "linearizedBaseContracts": [
          15897
                      "typeString": "bytes32"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "895:16:63"
            "id": 15797,
                {
                  "constant": false,
                  "id": 15790,
                  "mutability": "mutable",
                  "name": "tokens",
                  "nameLocation": "992:6:63",
                  "nodeType": "VariableDeclaration",
              "id": 15786,
                    "typeIdentifier": "t_array$_t_contract$_IERC20_$2941_$dyn_memory_ptr",
                    "typeString": "contract IERC20[]"
                  },
                  "typeName": {
                  "id": 15785,
                        "name": "IERC20",
                        "nodeType": "IdentifierPath",
                        "referencedDeclaration": 2941,
                        "src": "976:6:63"
                  "scope": 15797,
                        "typeString": "contract IERC20"
                      }
                    },
                    "id": 15789,
                    "nodeType": "ArrayTypeName",
                    "src": "976:8:63",
                    "typeDescriptions": {
                      "typeIdentifier": "t_array$_t_contract$_IERC20_$2941_$dyn_storage_ptr",
                    "id": 15784,
                {
                  "constant": false,
                  "id": 15793,
                  "mutability": "mutable",
                  "name": "balances",
                  "nameLocation": "1030:8:63",
                  "nodeType": "VariableDeclaration",
                  "scope": 15797,
                  "src": "1013:25:63",
                  "stateVariable": false,
                  "storageLocation": "memory",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_uint256_$dyn_memory_ptr",
                    "typeString": "uint256[]"
              "id": 15796,
                      "nodeType": "ElementaryTypeName",
                      "src": "1013:7:63",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                  "id": 15790,
                    "src": "1013:9:63",
                    "typeDescriptions": {
                      "typeIdentifier": "t_array$_t_uint256_$dyn_storage_ptr",
                      "typeString": "uint256[]"
                  "scope": 15797,
                  "constant": false,
                  "id": 15795,
                  "mutability": "mutable",
                  "name": "lastChangeBlock",
                  "nameLocation": "1061:15:63",
                  "nodeType": "VariableDeclaration",
                  "scope": 15797,
                  "src": "1053:23:63",
                  "stateVariable": false,
                      "id": 15788,
                      "nodeType": "UserDefinedTypeName",
                      "pathNode": {
                        "id": 15787,
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "961:126:63"
            },
            "scope": 15897,
            "src": "873:215:63",
            "stateMutability": "view",
                    "id": 15789,
              "id": 15798,
              "nodeType": "StructuredDocumentation",
              "src": "1096:2335:63",
              "text": " @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\n trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\n Pool shares.\n If the caller is not `sender`, it must be an authorized relayer for them.\n The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\n to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\n these maximums.\n If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\n this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\n WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\n back to the caller (not the sender, which is important for relayers).\n `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\n sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\n `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\n If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\n be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\n withdrawn from Internal Balance: attempting to do so will trigger a revert.\n This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\n their own custom logic. This typically requires additional information from the user (such as the expected number\n of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\n directly to the Pool's contract, as is `recipient`.\n Emits a `PoolBalanceChanged` event."
            },
            "functionSelector": "b95cac28",
            "id": 15810,
            "implemented": false,
            "kind": "function",
            "modifiers": [],
            "name": "joinPool",
                  "id": 15793,
              "parameters": [
                {
                  "constant": false,
                  "id": 15800,
                  "scope": 15797,
                  "src": "3465:14:63",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes32",
                    "typeString": "bytes32"
                  },
                  "typeName": {
                    "id": 15799,
                      "id": 15791,
                      "typeString": "bytes32"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 15802,
                    "id": 15792,
                  "src": "3490:14:63",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_address",
                    "typeString": "address"
                  },
                  "typeName": {
                    "id": 15801,
                    "name": "address",
                    "nodeType": "ElementaryTypeName",
                  "id": 15795,
                    }
                  },
                  "visibility": "internal"
                },
                  "scope": 15797,
                  "nameLocation": "3523:9:63",
                  "nodeType": "VariableDeclaration",
                  "scope": 15810,
                  "src": "3515:17:63",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_address",
                    "id": 15794,
                    "nodeType": "ElementaryTypeName",
                    "src": "3515:7:63",
                    "stateMutability": "nonpayable",
                    "typeDescriptions": {
                      "typeIdentifier": "t_address",
                      "typeString": "address"
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 15807,
            "scope": 15897,
                  "src": "3543:30:63",
                  "stateVariable": false,
                  "storageLocation": "memory",
                  "typeDescriptions": {
                    "typeIdentifier": "t_struct$_JoinPoolRequest_$15822_memory_ptr",
                    "typeString": "struct IVault.JoinPoolRequest"
                  },
              "id": 15798,
                      "name": "JoinPoolRequest",
                      "nodeType": "IdentifierPath",
                      "referencedDeclaration": 15822,
                      "src": "3543:15:63"
                    },
            "id": 15810,
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "3454:126:63"
            },
              "id": 15808,
            },
            "scope": 15897,
            "src": "3437:161:63",
            "stateMutability": "payable",
                  "id": 15800,
            "id": 15822,
            "members": [
              {
                "constant": false,
                  "scope": 15810,
                "scope": 15822,
                "src": "3640:15:63",
                "stateVariable": false,
                "storageLocation": "default",
                "typeDescriptions": {
                  "typeIdentifier": "t_array$_t_contract$_IAsset_$14358_$dyn_storage_ptr",
                  "typeString": "contract IAsset[]"
                },
                    "id": 15799,
                      "id": 15811,
                      "name": "IAsset",
                      "nodeType": "IdentifierPath",
                      "referencedDeclaration": 14358,
                      "src": "3640:6:63"
                    },
                    "referencedDeclaration": 14358,
                    "src": "3640:6:63",
                    "typeDescriptions": {
                      "typeIdentifier": "t_contract$_IAsset_$14358",
                      "typeString": "contract IAsset"
                    }
                  "id": 15802,
                    "typeIdentifier": "t_array$_t_contract$_IAsset_$14358_$dyn_storage_ptr",
                    "typeString": "contract IAsset[]"
                  }
                },
                  "scope": 15810,
                "mutability": "mutable",
                "name": "maxAmountsIn",
                "nameLocation": "3676:12:63",
                "nodeType": "VariableDeclaration",
                "scope": 15822,
                "src": "3666:22:63",
                "stateVariable": false,
                "storageLocation": "default",
                    "id": 15801,
                  "baseType": {
                    "id": 15815,
                    "name": "uint256",
                    "nodeType": "ElementaryTypeName",
                    "src": "3666:7:63",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "id": 15816,
                  "nodeType": "ArrayTypeName",
                  "src": "3666:9:63",
                  "id": 15804,
                "visibility": "internal"
              },
              {
                "constant": false,
                  "scope": 15810,
                "scope": 15822,
                "src": "3699:14:63",
                "stateVariable": false,
                "storageLocation": "default",
                "typeDescriptions": {
                  "typeIdentifier": "t_bytes_storage_ptr",
                  "typeString": "bytes"
                },
                    "id": 15803,
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes_storage_ptr",
                    "typeString": "bytes"
                  }
                },
                "visibility": "internal"
              },
              {
                "constant": false,
                "id": 15821,
                "mutability": "mutable",
                "name": "fromInternalBalance",
                "nameLocation": "3729:19:63",
                  "id": 15807,
                "typeDescriptions": {
                  "typeIdentifier": "t_bool",
                  "typeString": "bool"
                },
                  "scope": 15810,
                  "typeDescriptions": {
                    "typeIdentifier": "t_bool",
                    "typeString": "bool"
                  }
                    "typeIdentifier": "t_struct$_JoinPoolRequest_$15822_memory_ptr",
                    "typeString": "struct IVault.JoinPoolRequest"
                  },
                  "typeName": {
                    "id": 15806,
                    "nodeType": "UserDefinedTypeName",
                    "pathNode": {
                      "id": 15805,
                      "name": "JoinPoolRequest",
                      "nodeType": "IdentifierPath",
                      "referencedDeclaration": 15822,
                      "src": "3543:15:63"
                    },
                    "referencedDeclaration": 15822,
                    "src": "3543:15:63",
                    "typeDescriptions": {
                      "typeIdentifier": "t_struct$_JoinPoolRequest_$15822_storage_ptr",
                  "scope": 15835,
                  "src": "6321:14:63",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes32",
                    "typeString": "bytes32"
                  },
                  "typeName": {
              "id": 15809,
                      "typeIdentifier": "t_bytes32",
                      "typeString": "bytes32"
                    }
                  },
            "scope": 15897,
                  "mutability": "mutable",
                  "name": "sender",
                  "nameLocation": "6354:6:63",
                  "nodeType": "VariableDeclaration",
                  "scope": 15835,
                  "src": "6346:14:63",
                  "stateVariable": false,
            "id": 15822,
            "members": [
              {
                "constant": false,
                "id": 15814,
                      "typeString": "address"
                    }
                  },
                  "visibility": "internal"
                "scope": 15822,
                  "name": "recipient",
                  "nameLocation": "6387:9:63",
                  "nodeType": "VariableDeclaration",
                  "scope": 15835,
                  "typeIdentifier": "t_array$_t_contract$_IAsset_$14358_$dyn_storage_ptr",
                    "typeString": "address payable"
                  },
                  "typeName": {
                    "id": 15828,
                    "id": 15812,
                    "nodeType": "UserDefinedTypeName",
                    "pathNode": {
                      "id": 15811,
                      "name": "IAsset",
                      "nodeType": "IdentifierPath",
                      "referencedDeclaration": 14358,
                      "src": "3640:6:63"
                    },
                    "referencedDeclaration": 14358,
                    "src": "3640:6:63",
                    "typeDescriptions": {
                      "typeIdentifier": "t_contract$_IAsset_$14358",
                      "typeString": "contract IAsset"
                    }
                  },
                  "id": 15813,
                  "nodeType": "ArrayTypeName",
                  "src": "3640:8:63",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_contract$_IAsset_$14358_$dyn_storage_ptr",
              ],
              "src": "6310:134:63"
            },
            "returnParameters": {
              "id": 15834,
              "nodeType": "ParameterList",
              "parameters": [],
                "id": 15817,
            "virtual": false,
            "visibility": "external"
          },
          {
                "scope": 15822,
                "id": 15839,
                "mutability": "mutable",
                "name": "assets",
                "nameLocation": "6505:6:63",
                "nodeType": "VariableDeclaration",
                "scope": 15847,
                "src": "6496:15:63",
                "stateVariable": false,
                "storageLocation": "default",
                    "id": 15815,
                  "baseType": {
                    "id": 15837,
                    "nodeType": "UserDefinedTypeName",
                    "pathNode": {
                      "id": 15836,
                      "name": "IAsset",
                      "nodeType": "IdentifierPath",
                      "referencedDeclaration": 14358,
                  "id": 15816,
                      "typeIdentifier": "t_contract$_IAsset_$14358",
                      "typeString": "contract IAsset"
                    }
                  },
                  "id": 15838,
                  "nodeType": "ArrayTypeName",
                  "src": "6496:8:63",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_contract$_IAsset_$14358_$dyn_storage_ptr",
                    "typeString": "contract IAsset[]"
                  }
                "id": 15819,
                "id": 15842,
                "mutability": "mutable",
                "name": "minAmountsOut",
                "nameLocation": "6532:13:63",
                "scope": 15822,
                "typeDescriptions": {
                  "typeIdentifier": "t_array$_t_uint256_$dyn_storage_ptr",
                  "typeString": "uint256[]"
                },
                "typeName": {
                  "baseType": {
                    "id": 15840,
                    "name": "uint256",
                  "id": 15818,
                    }
                  },
                  "id": 15841,
                  "nodeType": "ArrayTypeName",
                  "src": "6522:9:63",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_uint256_$dyn_storage_ptr",
                    "typeString": "uint256[]"
                  }
                },
                "visibility": "internal"
              },
                "id": 15821,
                "nameLocation": "6562:8:63",
                "nodeType": "VariableDeclaration",
                "scope": 15847,
                "src": "6556:14:63",
                "scope": 15822,
                },
                "typeName": {
                  "id": 15843,
                  "name": "bytes",
                  "nodeType": "ElementaryTypeName",
                  "src": "6556:5:63",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes_storage_ptr",
                  "id": 15820,
              {
                "constant": false,
                "id": 15846,
                "mutability": "mutable",
                "name": "toInternalBalance",
                "nameLocation": "6586:17:63",
                "nodeType": "VariableDeclaration",
                "scope": 15847,
                "src": "6581:22:63",
                "stateVariable": false,
                "storageLocation": "default",
                "typeDescriptions": {
                  "typeIdentifier": "t_bool",
                  "typeString": "bool"
            "scope": 15897,
                  "src": "6581:4:63",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bool",
                    "typeString": "bool"
                  }
              "id": 15823,
            "nameLocation": "6469:15:63",
            "nodeType": "StructDefinition",
            "scope": 15897,
            "src": "6462:149:63",
            "visibility": "public"
            "id": 15835,
              {
                "id": 15848,
                "name": "GIVEN_IN",
                "nameLocation": "10263:8:63",
                "nodeType": "EnumValue",
                "src": "10263:8:63"
              },
              "id": 15833,
                "src": "10273:9:63"
              }
            ],
            "name": "SwapKind",
                  "id": 15825,
            "documentation": {
              "id": 15851,
              "nodeType": "StructuredDocumentation",
              "src": "10292:2008:63",
                  "scope": 15835,
            "kind": "function",
            "modifiers": [],
            "name": "batchSwap",
            "nameLocation": "12315:9:63",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 15871,
              "nodeType": "ParameterList",
                    "id": 15824,
                  "name": "kind",
                  "nameLocation": "12344:4:63",
                  "nodeType": "VariableDeclaration",
                  "scope": 15876,
                  "src": "12335:13:63",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_enum$_SwapKind_$15850",
                    "typeString": "enum IVault.SwapKind"
                  },
                  "typeName": {
                  "id": 15827,
                      "nodeType": "IdentifierPath",
                      "referencedDeclaration": 15850,
                      "src": "12335:8:63"
                    },
                  "scope": 15835,
                    }
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 15858,
                  "mutability": "mutable",
                    "id": 15826,
                  "stateVariable": false,
                  "storageLocation": "memory",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_struct$_BatchSwapStep_$15887_memory_ptr_$dyn_memory_ptr",
                    "typeString": "struct IVault.BatchSwapStep[]"
                  },
                  "typeName": {
                    "baseType": {
                      "id": 15856,
                      "nodeType": "UserDefinedTypeName",
                      "pathNode": {
                        "id": 15855,
                        "name": "BatchSwapStep",
                  "id": 15829,
                      "src": "12359:13:63",
                      "typeDescriptions": {
                        "typeIdentifier": "t_struct$_BatchSwapStep_$15887_storage_ptr",
                        "typeString": "struct IVault.BatchSwapStep"
                  "scope": 15835,
                    "typeDescriptions": {
                      "typeIdentifier": "t_array$_t_struct$_BatchSwapStep_$15887_storage_$dyn_storage_ptr",
                      "typeString": "struct IVault.BatchSwapStep[]"
                    }
                  },
                  "visibility": "internal"
                },
                {
                    "id": 15828,
                  "nodeType": "VariableDeclaration",
                  "scope": 15876,
                  "src": "12398:22:63",
                  "stateVariable": false,
                  "storageLocation": "memory",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_contract$_IAsset_$14358_$dyn_memory_ptr",
                    "typeString": "contract IAsset[]"
                  },
                  "typeName": {
                    "baseType": {
                      "id": 15860,
                      "nodeType": "UserDefinedTypeName",
                  "id": 15832,
                        "src": "12398:6:63"
                      },
                      "referencedDeclaration": 14358,
                      "src": "12398:6:63",
                  "scope": 15835,
                    "id": 15861,
                    "nodeType": "ArrayTypeName",
                    "src": "12398:8:63",
                    "typeDescriptions": {
                    "typeIdentifier": "t_struct$_ExitPoolRequest_$15847_memory_ptr",
                    "typeString": "struct IVault.ExitPoolRequest"
                  },
                  "typeName": {
                    "id": 15831,
                    "nodeType": "UserDefinedTypeName",
                    "pathNode": {
                      "id": 15830,
                      "name": "ExitPoolRequest",
                      "nodeType": "IdentifierPath",
                      "referencedDeclaration": 15847,
                      "src": "6407:15:63"
                    },
                    "referencedDeclaration": 15847,
                    "src": "6407:15:63",
                    "typeDescriptions": {
                      "typeIdentifier": "t_struct$_ExitPoolRequest_$15847_storage_ptr",
                  },
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 15868,
                  "mutability": "mutable",
                  "name": "limits",
                  "nameLocation": "12485:6:63",
              "id": 15834,
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_int256_$dyn_memory_ptr",
                    "typeString": "int256[]"
                  },
            "scope": 15897,
                      "src": "12469:6:63",
                      "typeDescriptions": {
                        "typeIdentifier": "t_int256",
                        "typeString": "int256"
                      }
                    },
                    "id": 15867,
            "id": 15847,
            "members": [
              {
                "constant": false,
                "id": 15839,
                  "name": "deadline",
                  "nameLocation": "12510:8:63",
                  "nodeType": "VariableDeclaration",
                  "scope": 15876,
                "scope": 15847,
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 15869,
                  "typeIdentifier": "t_array$_t_contract$_IAsset_$14358_$dyn_storage_ptr",
                      "typeString": "uint256"
                    }
                  },
                  "visibility": "internal"
                    "id": 15837,
                    "nodeType": "UserDefinedTypeName",
                    "pathNode": {
                      "id": 15836,
                      "name": "IAsset",
                      "nodeType": "IdentifierPath",
                      "referencedDeclaration": 14358,
                      "src": "6496:6:63"
                    },
                    "referencedDeclaration": 14358,
                    "src": "6496:6:63",
                    "typeDescriptions": {
                      "typeIdentifier": "t_contract$_IAsset_$14358",
                      "typeString": "contract IAsset"
                    }
                  },
                  "id": 15838,
                  "nodeType": "ArrayTypeName",
                  "src": "6496:8:63",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_contract$_IAsset_$14358_$dyn_storage_ptr",
              "src": "12551:17:63"
            },
            "scope": 15897,
            "src": "12306:263:63",
            "stateMutability": "payable",
            "virtual": false,
            "visibility": "external"
                "id": 15842,
              {
                "constant": false,
                "id": 15878,
                "mutability": "mutable",
                "scope": 15847,
                "stateVariable": false,
                "storageLocation": "default",
                "typeDescriptions": {
                  "typeIdentifier": "t_bytes32",
                  "typeString": "bytes32"
                },
                "typeName": {
                  "id": 15877,
                  "name": "bytes32",
                    "id": 15840,
                  }
                },
                "visibility": "internal"
              },
              {
                "constant": false,
                "id": 15880,
                "mutability": "mutable",
                  "id": 15841,
                "stateVariable": false,
                "storageLocation": "default",
                "typeDescriptions": {
                  "typeIdentifier": "t_uint256",
                  "typeString": "uint256"
                },
                "typeName": {
                  "id": 15879,
                  "name": "uint256",
                  "nodeType": "ElementaryTypeName",
                  "src": "13200:7:63",
                "id": 15844,
                "visibility": "internal"
              },
              {
                "constant": false,
                "scope": 15847,
                "scope": 15887,
                "src": "13231:21:63",
                "stateVariable": false,
                "storageLocation": "default",
                "typeDescriptions": {
                  "typeIdentifier": "t_uint256",
                  "typeString": "uint256"
                },
                  "id": 15843,
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  }
                },
                "visibility": "internal"
              },
              {
                "constant": false,
                "id": 15884,
                "mutability": "mutable",
                "name": "amount",
                "id": 15846,
                "storageLocation": "default",
                "typeDescriptions": {
                  "typeIdentifier": "t_uint256",
                  "typeString": "uint256"
                "scope": 15847,
                  "src": "13263:7:63",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  }
                },
                "visibility": "internal"
              },
                  "id": 15845,
                "nameLocation": "13294:8:63",
                "nodeType": "VariableDeclaration",
                "scope": 15887,
                "src": "13288:14:63",
                "stateVariable": false,
                "storageLocation": "default",
                "typeDescriptions": {
                  "typeIdentifier": "t_bytes_storage_ptr",
                  "typeString": "bytes"
                },
                "typeName": {
                  "id": 15885,
                  "name": "bytes",
                  "nodeType": "ElementaryTypeName",
            "scope": 15897,
                },
                "visibility": "internal"
              }
            ],
            "name": "BatchSwapStep",
            "id": 15850,
            "members": [
              {
                "id": 15848,
                "constant": false,
                "id": 15889,
                "mutability": "mutable",
                "name": "sender",
                "nameLocation": "14303:6:63",
                "nodeType": "VariableDeclaration",
                "id": 15849,
                  "typeIdentifier": "t_address",
                  "typeString": "address"
                },
                "typeName": {
                  "id": 15888,
                  "name": "address",
                  "nodeType": "ElementaryTypeName",
                  "src": "14295:7:63",
                  "stateMutability": "nonpayable",
                  "typeDescriptions": {
                    "typeIdentifier": "t_address",
                    "typeString": "address"
                  }
              "id": 15851,
                "id": 15891,
                "mutability": "mutable",
                "name": "fromInternalBalance",
                "nameLocation": "14325:19:63",
                "nodeType": "VariableDeclaration",
            "id": 15876,
                  "typeIdentifier": "t_bool",
                  "typeString": "bool"
                },
                "typeName": {
                  "id": 15890,
                  "name": "bool",
                  "nodeType": "ElementaryTypeName",
              "id": 15871,
                },
                "visibility": "internal"
              },
              {
                  "id": 15854,
                "nodeType": "VariableDeclaration",
                "scope": 15896,
                "src": "14355:25:63",
                "stateVariable": false,
                  "scope": 15876,
                "typeName": {
                  "id": 15892,
                  "name": "address",
                  "nodeType": "ElementaryTypeName",
                    "typeIdentifier": "t_enum$_SwapKind_$15850",
                    "typeString": "enum IVault.SwapKind"
                  },
                  "typeName": {
                    "id": 15853,
                    "nodeType": "UserDefinedTypeName",
                    "pathNode": {
                      "id": 15852,
                      "name": "SwapKind",
                      "nodeType": "IdentifierPath",
                      "referencedDeclaration": 15850,
                      "src": "12335:8:63"
                    },
                    "referencedDeclaration": 15850,
                    "src": "12335:8:63",
                    "typeDescriptions": {
                      "typeIdentifier": "t_enum$_SwapKind_$15850",
            "name": "FundManagement",
            "nameLocation": "14269:14:63",
            "nodeType": "StructDefinition",
            "scope": 15897,
            "src": "14262:159:63",
            "visibility": "public"
          }
                  "id": 15858,
    ],
    "src": "702:13722:63"
  },
  "compiler": {
                  "scope": 15876,
  "updatedAt": "2022-09-08T11:08:47.947Z",
  "devdoc": {
    "kind": "dev",
    "methods": {
                    "typeIdentifier": "t_array$_t_struct$_BatchSwapStep_$15887_memory_ptr_$dyn_memory_ptr",
      },
      "joinPool(bytes32,address,address,(address[],uint256[],bytes,bool))": {
        "details": "Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized Pool shares. If the caller is not `sender`, it must be an authorized relayer for them. The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces these maximums. If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent back to the caller (not the sender, which is important for relayers). `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final `assets` array might not be sorted. Pools with no registered tokens cannot be joined. If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be withdrawn from Internal Balance: attempting to do so will trigger a revert. This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement their own custom logic. This typically requires additional information from the user (such as the expected number of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed directly to the Pool's contract, as is `recipient`. Emits a `PoolBalanceChanged` event."
      }
                      "id": 15856,
                      "nodeType": "UserDefinedTypeName",
                      "pathNode": {
                        "id": 15855,
                        "name": "BatchSwapStep",
                        "nodeType": "IdentifierPath",
                        "referencedDeclaration": 15887,
                        "src": "12359:13:63"
                      },
                      "referencedDeclaration": 15887,
                      "src": "12359:13:63",
                      "typeDescriptions": {
                        "typeIdentifier": "t_struct$_BatchSwapStep_$15887_storage_ptr",
                        "typeString": "struct IVault.BatchSwapStep"
                      }
                    },
                    "id": 15857,
                    "nodeType": "ArrayTypeName",
                    "src": "12359:15:63",
                    "typeDescriptions": {
                      "typeIdentifier": "t_array$_t_struct$_BatchSwapStep_$15887_storage_$dyn_storage_ptr",
                  "id": 15862,
                  "scope": 15876,
                    "typeIdentifier": "t_array$_t_contract$_IAsset_$14358_$dyn_memory_ptr",
                      "id": 15860,
                      "nodeType": "UserDefinedTypeName",
                      "pathNode": {
                        "id": 15859,
                        "name": "IAsset",
                        "nodeType": "IdentifierPath",
                        "referencedDeclaration": 14358,
                        "src": "12398:6:63"
                      },
                      "referencedDeclaration": 14358,
                      "src": "12398:6:63",
                      "typeDescriptions": {
                        "typeIdentifier": "t_contract$_IAsset_$14358",
                        "typeString": "contract IAsset"
                      }
                    },
                    "id": 15861,
                    "nodeType": "ArrayTypeName",
                    "src": "12398:8:63",
                    "typeDescriptions": {
                      "typeIdentifier": "t_array$_t_contract$_IAsset_$14358_$dyn_storage_ptr",
                  "id": 15865,
                  "scope": 15876,
                    "typeIdentifier": "t_struct$_FundManagement_$15896_memory_ptr",
                    "typeString": "struct IVault.FundManagement"
                  },
                  "typeName": {
                    "id": 15864,
                    "nodeType": "UserDefinedTypeName",
                    "pathNode": {
                      "id": 15863,
                      "name": "FundManagement",
                      "nodeType": "IdentifierPath",
                      "referencedDeclaration": 15896,
                      "src": "12431:14:63"
                    },
                    "referencedDeclaration": 15896,
                    "src": "12431:14:63",
                    "typeDescriptions": {
                      "typeIdentifier": "t_struct$_FundManagement_$15896_storage_ptr",
                  "id": 15868,
                  "scope": 15876,
                      "id": 15866,
                    "id": 15867,
                  "id": 15870,
                  "scope": 15876,
                    "id": 15869,
              "id": 15875,
                  "id": 15874,
                  "scope": 15876,
                      "id": 15872,
                    "id": 15873,
            "scope": 15897,
            "id": 15887,
            "members": [
              {
                "constant": false,
                "id": 15878,
                "scope": 15887,
                  "id": 15877,
                "id": 15880,
                "scope": 15887,
                  "id": 15879,
                "id": 15882,
                "scope": 15887,
                  "id": 15881,
                "id": 15884,
                "scope": 15887,
                  "id": 15883,
                "id": 15886,
                "scope": 15887,
                  "id": 15885,
            "scope": 15897,
            "id": 15896,
            "members": [
              {
                "constant": false,
                "id": 15889,
                "scope": 15896,
                  "id": 15888,
                "id": 15891,
                "scope": 15896,
                  "id": 15890,
                "id": 15893,
                "scope": 15896,
                  "id": 15892,
                "id": 15895,
                "scope": 15896,
                  "id": 15894,
            "scope": 15897,
        "scope": 15898,
  "schemaVersion": "3.4.9",
  "updatedAt": "2022-09-08T11:08:47.947Z",
